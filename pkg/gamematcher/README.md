# gamematcher

### 诛仙

很多人都看过诛仙，应该对七脉会武印象深刻。

> “在那红木箱子之中，共有六十三粒蜡丸，其中各包着一张字条，上书着从一至六十三此类数字……”众弟子忽地一阵喧哗，苍松道人不去理会，又道：“在抽签完成之后，即以数字为准进行比试，以一号对六十四，二对六十三，三对六十二如此类推，其后第二轮，则以一号与六十四的胜者对二号与六十三的胜者，如此类推，一直到最后决战。诸位明白了么？”
>
> ...
>
> 待众人声息稍稍平复，苍松真人才正色道：“不过这也不是什么难事，在那六十三粒蜡丸中，只要有哪位弟子抽中了一号，那便是幸运之极了，因为并无六十四号对手，所以他首轮轮空。”

不知道诸位明白了么，其实作者在这里犯了一个错误。

第一轮是首尾对称匹配：1+64 = 2+63 = 3+62 = ... = 32+33。

假设第一轮全部由序号小的弟子取胜，那么第二轮就是一号对二号。

”如此类推“只有一项怎么类推？苍松真人道法虽深，数学归纳法学得却不怎么样。

我们假设苍松真人指的是三号对四号、五号对六号，那就是紧邻连续匹配：2-1 = 4-3 = 6-5 = ... = 32-31。

两种匹配规则是完全不一样的，那么第三轮、第四轮、第五轮到底是参照第一轮首尾对称匹配还是参照第二轮紧邻连续匹配，苍松真人没有说。可能修仙之人智商都比较高不必明说吧。

> “啊，我是二十六。”
>
> “我是三十三，咦，你是多少？” （从后文看33是曾书书，这里表现不太沉稳啊）
>
> “哦，我是四十七，不知道对手是几号，我算算……”

但是从众参赛弟子的反应来看，并没有想象中的那么智商超群，也得像小学生一样数指头。

> 张小凡点了点头，道：“曾师兄你呢？”
>
> 曾：“我也是，昨日抽签我抽得了三十三号，不知你是几号，可不要这么巧，我们就是今日的对手了？”
>
> 张小凡也笑了起来，道：“我是一号。”
>
> 曾：“你便是昨日大竹峰的那个弟子？”
>
> 张小凡脸上一红，点了点头。
>
> 曾：“你运气真好，”说着在心里一算，随即道：“我们要到了最后决战才能碰面，看来难度很大啊。”

到这里就引出了问题：任意给定两个选手，如何判断他们在第几轮相遇。

当然我们不再局限于64人，同时支持128、256等等。

### 网球大满贯

大满贯由128名选手参赛，并设置种子选手，大的原则是首尾对称匹配。

为了增加一些随机性添加了抽签环节，譬如1号种子的第一轮对手不一定是128号，也有可能是98号。

但是设置种子的目的就是为了避免高手之间过早相遇，必然有一个早早淘汰出局。

因此1号种子和2号种子如果中途没有爆冷出局，那么他们只可能在决赛（第7轮）相遇。

这里引出了同样的问题：任意给定两个选手，如何判断他们在第几轮相遇。

不同匹配规则下相遇轮次是不一样的，我们希望都能够支持。

### 实现

现实世界中多是1-based，头号种子就是1，但是大多数编程语言又是0-based，第一个数字是0而不是1。

因此面向用户采用1-based，实现细节采用0-based。（后续会看到0-based在位运算中的优势）

我们以0-based的64人淘汰赛为例，首先考虑一种简单的情况，永远都是序号小的选手获胜晋级下一轮。

先从简单情况找出内在规律，然后推广到复杂的情况中去。

#### 简单情况

##### 紧邻连续匹配

第一轮

```
0	1		000000	000001
2	3		000010	000011
4	5		000100	000101
6	7		000110	000111
8	9		001000	001001
10	11		001010	001011
12	13		001100	001101
14	15		001110	001111
16	17		010000	010001
18	19		010010	010011
20	21		010100	010101
22	23		010110	010111
24	25		011000	011001
26	27		011010	011011
28	29		011100	011101
30	31		011110	011111
32	33		100000	100001
34	35		100010	100011
36	37		100100	100101
38	39		100110	100111
40	41		101000	101001
42	43		101010	101011
44	45		101100	101101
46	47		101110	101111
48	49		110000	110001
50	51		110010	110011
52	53		110100	110101
54	55		110110	110111
56	57		111000	111001
58	59		111010	111011
60	61		111100	111101
62	63		111110	111111
此时规律还不明显，两数之间差1，不过也许可以是其它形式，接着往下看。
```

第二轮

```
0	2		000000	000010
4	6		000100	000110
8	10		001000	001010
12	14		001100	001110
16	18		010000	010010
20	22		010100	010110
24	26		011000	011010
28	30		011100	011110
32	34		100000	100010
36	38		100100	100110
40	42		101000	101010
44	46		101100	101110
48	50		110000	110010
52	54		110100	110110
56	58		111000	111010
60	62		111100	111110
两数之间差2,也许可以推测后续差3（等差数列）或者差4（等比数列）。
这时又有新的发现，那就是第一列都是4的倍数。再回头看第一轮，第一列都是2的倍数。
```

第三轮

```
0	4		000000	000100
8	12		001000	001100
16	20		010000	010100
24	28		011000	011100
32	36		100000	100100
40	44		101000	101100
48	52		110000	110100
56	60		111000	111100
两数之间差4，几乎可以确认等比数列的规律了。
第一列都是8的倍数，可以预测接下来都是16的倍数。
也许这个发现可以解释“40和36也是差4,为什么40对阵44而不是40对阵36”的问题。
```

第四轮

```
0	8		000000	001000
16	24		010000	011000
32	40		100000	101000
48	56		110000	111000
完美继承了两数之间差8和第一列16倍数的规律。
此时可以考虑怎么用更结构化形式表达出来了。
观察两个数字的二进制表示可以发现有且只有第4个bit不一样，在第三轮的时候只有第3个bit不一样，第二轮是第2个bit，第一轮是第1个。
```

第五轮

```
0	16		000000	010000
32	48		100000	110000
有且只有第5个bit不一样，接下来第六轮也是。
用XOR表示就是，p^q=10000。这种方法有一个好处就是p^q=q^p，不需要考虑大小问题，作差法就必须考虑大小顺序。
第六轮就是，p^q=100000，0的个数随着轮次增加而增加。
```

第六轮

```
0	32		000000	100000
注意p^q=100000并不能确定两个数就一定是000000和100000，譬如100011^000011也是100000。
后面在复杂情况的章节会解释如何避免后者出现，同时也就无需添加第一列是某次幂倍数的条件。
```

##### 首尾对称匹配

第一轮

```
0	63		000000	111111
1	62		000001	111110
2	61		000010	111101
3	60		000011	111100
4	59		000100	111011
5	58		000101	111010
6	57		000110	111001
7	56		000111	111000
8	55		001000	110111
9	54		001001	110110
10	53		001010	110101
11	52		001011	110100
12	51		001100	110011
13	50		001101	110010
14	49		001110	110001
15	48		001111	110000
16	47		010000	101111
17	46		010001	101110
18	45		010010	101101
19	44		010011	101100
20	43		010100	101011
21	42		010101	101010
22	41		010110	101001
23	40		010111	101000
24	39		011000	100111
25	38		011001	100110
26	37		011010	100101
27	36		011011	100100
28	35		011100	100011
29	34		011101	100010
30	33		011110	100001
31	32		011111	100000
有了紧邻连续匹配的铺垫，再找这里的规律就容易多了。
两数之和是63，或许写成p^q=63=0b111111会更容易看出规律。
```

第二轮

```
0	31		000000	011111
1	30		000001	011110
2	29		000010	011101
3	28		000011	011100
4	27		000100	011011
5	26		000101	011010
6	25		000110	011001
7	24		000111	011000
8	23		001000	010111
9	22		001001	010110
10	21		001010	010101
11	20		001011	010100
12	19		001100	010011
13	18		001101	010010
14	17		001110	010001
15	16		001111	010000
两数之和是31，p^q=31=0b11111
```

第三轮

```
0	15		000000	001111
1	14		000001	001110
2	13		000010	001101
3	12		000011	001100
4	11		000100	001011
5	10		000101	001010
6	9		000110	001001
7	8		000111	001000
两数之和是15，p^q=0b1111
```

第四轮

```
0	7		000000	000111
1	6		000001	000110
2	5		000010	000101
3	4		000011	000100
两数之和是7，p^q=0b111
规律就很明显了：p^q+1是2的幂次，幂次随着轮次增加而减小。
```

第五轮

```
0	3		000000	000011
1	2		000001	000010
p^q=0b11
```

第六轮

```
0	1		000000	000001
p^q=0b1
```

#### 复杂情况

##### 紧邻连续匹配

前面已经找到了规律：`p^q=0b1`则第一轮相遇，`p^q=0b10`则第二轮相遇，`p^q=0b100`则第三轮相遇，`p^q=0b1000`则第四轮相遇，`p^q=0b10000`则第五轮相遇，`p^q=0b100000`则第六轮相遇。

现在不一定是序号小的获胜晋级了，那么第二轮就有可能是

```																																																												
0/1		2/3
4/5		6/7				6 ^ 0b1 = 7		7 ^ 0b1 = 6
8/9		10/11
12/13	14/15
...
4n/4n+1	4n+2/4n+3
```

如此就出现了4种组合方式，如果不尽早找到一种统一的方式，第三轮就是8种组合方式，第四轮就是16种……

根据前面的经验，需要一个公式，输入`4n`或者`4n+1`得到`4n`，输入`4n+2`或者`4n+3`得到`4n+2`。这对于熟悉二进制的人来说并不难，截去最后1个bit就可以了。

一番操作之后进入第三轮：

```
0/2		4/6
8/10	12/14			12 ^ 0b10 = 14		14 ^ 0b10 = 12
16/18	20/22
...
8n/8n+2	8n+4/8n+6
```

有了上面的经验，这次截去最后2个bit就可以了。

后续就是一路截去尾部bit的操作，有兴趣自行验算。

回答前面遗留的问题：100011^000011也是100000，为什么不会出现这种情况。

因为这一路上一直在截去尾部的bit，当到达100000的时候已经经历了5轮截断操作，尾部一定是00000。

###### 优化模式

追求统一方式的主要用于计算对手，如果不追求一种统一的方式又怎么样呢？

| 轮次 |                             p^q                              |    备注     |
| :--: | :----------------------------------------------------------: | :---------: |
|  1   |                              1                               | 1位二进制数 |
|  2   |                            10 11                             | 2位二进制数 |
|  3   |                       100 101 110 111                        | 3位二进制数 |
|  4   |         1000 1001 1010 1011<br/>1100 1101 1110 1111          | 4位二进制数 |
|  5   | 10000 10001 10010 10011<br/>           10100 10101 10110 10111<br/>           11000 11001 11010 11011<br/>11100 11101 11110 11111 | 5位二进制数 |
|  6   |                             ...                              | 6位二进制数 |

**因此`p^q`的二进制表示是几位数，那么`p`和`q`就在第几轮相遇。**

##### 首尾对称匹配

前面已经找到了规律：`p^q=0b111111`则第一轮相遇，`p^q=0b11111`则第二轮相遇，`p^q=0b1111`则第三轮相遇，`p^q=0b111`则第四轮相遇，`p^q=0b11`则第五轮相遇，`p^q=0b1`则第六轮相遇。

同样的，不保证号码小的晋级，第二轮就是

```
0/63	31/32
1/62	30/33			0b111111 ^ 30 = 33		0b11111 ^ 33 = 30
2/61	29/34
3/60	28/35
...
p/63-p	q/63-q
```

同样的，需要一个公式，输入`0`或`63`得到`0`，输入`31`或者`32`得到`31`，那么`min(x, 63-x)`就满足要求。

一番操作之后进入第三轮：

```
0/31	15/16
1/30	14/17			0b11111 ^ 14 = 17		0b11111 ^ 17 = 14
2/29	13/18
...
p/31-p	q/31-q
```

这一次就变成了`min(x, 31-x)`，或许改成`min(x, (1<<5-1)^x)`更容易看出规律。

接下来就是`min(x, (1<<4-1)^x)`和`min(x, (1<<3-1)^x)`，这次确实可以“如此类推”了。

###### 优化模式

追求统一方式的主要用于计算对手，如果不追求一种统一的方式又怎么样呢？

| 轮次 |                             p^q                              |      备注      |
| :--: | :----------------------------------------------------------: | :------------: |
|  1   |                            111111                            |  尾部连续6个1  |
|  2   |                        011111 100000                         | 尾部连续5个1/0 |
|  3   |               001111 010000<br/>101111 110000                | 尾部连续4个1/0 |
|  4   | 000111 001000<br/>            010111 011000<br/>           100111 101000<br/>110111 111000 | 尾部连续3个1/0 |
|  5   | 000011 000100<br/>             001011 001100 <br/>             010011 010100 <br/>             011011 011100 <br/>            100011 100100 <br/>            101011 101100 <br/>             110011 110100 <br/>111011 111100 | 尾部连续2个1/0 |
|  6   |                             ...                              | 尾部连续1个1/0 |

**因此`p^q`的二进制表示尾部有几个连续的0或1，那么`p`和`q`就在倒数第几轮相遇。**

#### 晋级过程中遇到的对手

##### 紧邻连续匹配

第二轮的可能情况：

```
0/1		2/3
4/5		6/7				6 ^ 0b1 = 7		7 ^ 0b1 = 6
8/9		10/11
12/13	14/15
...
```

那么第一轮的对手就是`x ^ 0b1`。

第三轮的可能情况：

```
0/2		4/6
8/10	12/14			12 ^ 0b10 = 14		14 ^ 0b10 = 12
16/18	20/22
...
```

那么第二轮的对手就是`x ^ 0b10`。

接下来第三轮是`x ^ 0b100`，第四轮是`x ^ 0b1000`，“如此类推”。

##### 首尾对称匹配

第二轮的可能情况：

```
0/63	31/32
1/62	30/33			0b111111 ^ 30 = 33		0b11111 ^ 33 = 30
2/61	29/34
3/60	28/35
...
```

那么第一轮的对手就是`0b111111 ^ x`。

第三轮的可能情况：

```
0/31	15/16
1/30	14/17			0b11111 ^ 14 = 17		0b11111 ^ 17 = 14
2/29	13/18
...
```

那么第二轮的对手就是`0b11111 ^ x`。

接下来第三轮是`0b1111 ^ x`，第四轮是`0b111 ^ x`，“如此类推”。

### Examples

##### 紧邻连续匹配（optimized模式）

备注：该模式的`ps`和`qs`无意义。

```go
package main

import (
	"fmt"

	"github.com/Neightly/juzhongmishi/pkg/gamematcher"
)

func main() {
	game := gamematcher.New(64)             // 64人紧邻连续匹配的比赛
	l, ps, qs := game.MatchCloseNext(1, 33) // 1号张小凡和33号曾书书只能在决赛（第6轮）相遇
	_, _ = ps, qs                           // 备注：非verbose模式的ps和qs无意义。
	fmt.Println(l)
	// Output: 6
}
```

##### 首尾对称匹配（optimized模式）

备注：该模式的`ps`和`qs`无意义。

```go
package main

import (
	"fmt"

	"github.com/Neightly/juzhongmishi/pkg/gamematcher"
)

func main() {
	game := gamematcher.New(128)          // 128人首尾对称匹配的比赛
	l, ps, qs := game.MatchHeadTail(1, 2) // 1号种子和2号种子只能在决赛（第7轮）相遇
	_, _ = ps, qs                         // 备注：非verbose模式的ps和qs无意义。
	fmt.Println(l)
	// Output: 7
}
```

##### 紧邻连续匹配（verbose模式）

备注：如果关注晋级过程中遇到的对手，需要使用verbose模式。非verbose模式的ps和qs无意义。

```go
package main

import (
	"fmt"

	"github.com/Neightly/juzhongmishi/pkg/gamematcher"
)

func main() {
	game := gamematcher.New(64).Verbose()    // 64人紧邻连续匹配的比赛，verbose模式
	l, ps, qs := game.MatchCloseNext(13, 58) // 13号和58号相遇在第6轮
	fmt.Println(l)
	// 第一轮战胜14, 第二轮战胜15, 第三轮战胜9， 第四轮战胜1, 第五轮战胜17， 第六轮遇上58
	fmt.Println(ps)
	// 第一轮战胜57, 第二轮战胜59, 第三轮战胜61， 第四轮战胜49, 第五轮战胜33， 第六轮遇上13
	fmt.Println(qs)
	// Output:
	// 6
	// [13:->14 13:->15 13:<-9 9:<-1 1:->17 1:33(58)]
	// [58:<-57 57:->59 57:->61 57:<-49 49:<-33 33:1(13)]
}
```

##### 首尾对称匹配（verbose模式）

备注：如果关注晋级过程中遇到的对手，需要使用verbose模式。非verbose模式的ps和qs无意义。

```go
package main

import (
	"fmt"

	"github.com/Neightly/juzhongmishi/pkg/gamematcher"
)

func main() {
	game := gamematcher.New(128).Verbose()  // 128人首尾对称匹配的比赛，verbose模式
	l, ps, qs := game.MatchHeadTail(45, 74) // 45号和74号相遇在第7轮
	fmt.Println(l)
	// 第一轮战胜84, 第二轮战胜20, 第三轮战胜13， 第四轮战胜4, 第五轮战胜5， 第六轮战胜1, 第七轮遇上74
	fmt.Println(ps)
	// 第一轮战胜55, 第二轮战胜10, 第三轮战胜23， 第四轮战胜7, 第五轮战胜2， 第六轮战胜3, 第七轮遇上45
	fmt.Println(qs)
	// Output:
	// 7
	// [45:->84 45:<-20 20:<-13 13:<-4 4:->5 4:<-1 1:2(74)]
	// [74:<-55 55:<-10 10:->23 10:<-7 7:<-2 2:->3 2:1(45)]
}
```

