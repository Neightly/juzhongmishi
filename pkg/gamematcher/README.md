# `gamematcher`

### 诛仙

很多人都看过诛仙，应该对七脉会武印象深刻。

> “在那红木箱子之中，共有六十三粒蜡丸，其中各包着一张字条，上书着从一至六十三此类数字……”众弟子忽地一阵喧哗，苍松道人不去理会，又道：“在抽签完成之后，即以数字为准进行比试，以一号对六十四，二对六十三，三对六十二如此类推，其后第二轮，则以一号与六十四的胜者对二号与六十三的胜者，如此类推，一直到最后决战。诸位明白了么？”
>
> ...
>
> 待众人声息稍稍平复，苍松真人才正色道：“不过这也不是什么难事，在那六十三粒蜡丸中，只要有哪位弟子抽中了一号，那便是幸运之极了，因为并无六十四号对手，所以他首轮轮空。”

不知道诸位明白了么，其实作者在这里犯了一个错误。

第一轮是首尾对称匹配：1+64 = 2+63 = 3+62 = ... = 32+33。

假设第一轮全部由序号小的弟子取胜，那么第二轮就是一号对二号。

”如此类推“只有一项怎么类推？苍松真人道法虽深，数学归纳法学得却不怎么样。

我们假设苍松真人指的是三号对四号、五号对六号，那就是紧邻连续匹配：2-1 = 4-3 = 6-5 = ... = 32-31。

两种匹配规则是完全不一样的，那么第三轮、第四轮、第五轮到底是参照第一轮首尾对称匹配还是参照第二轮紧邻连续匹配，苍松真人没有说。可能修仙之人智商都比较高不必明说吧。

> “啊，我是二十六。”
>
> “我是三十三，咦，你是多少？” （从后文看33是曾书书，这里表现不太沉稳啊）
>
> “哦，我是四十七，不知道对手是几号，我算算……”

但是从众参赛弟子的反应来看，并没有想象中的那么智商超群，也得像小学生一样数指头。

> 张小凡点了点头，道：“曾师兄你呢？”
>
> 曾：“我也是，昨日抽签我抽得了三十三号，不知你是几号，可不要这么巧，我们就是今日的对手了？”
>
> 张小凡也笑了起来，道：“我是一号。”
>
> 曾：“你便是昨日大竹峰的那个弟子？”
>
> 张小凡脸上一红，点了点头。
>
> 曾：“你运气真好，”说着在心里一算，随即道：“我们要到了最后决战才能碰面，看来难度很大啊。”

到这里就引出了问题：任意给定两个选手，如何判断他们在第几轮相遇。

当然我们不再局限于64人，同时支持128、256等等。

### 网球大满贯

大满贯由128名选手参赛，并设置种子选手，大的原则是首尾对称匹配。

为了增加一些随机性添加了抽签环节，譬如1号种子的第一轮对手不一定是128号，也有可能是98号。

但是设置种子的目的就是为了避免高手之间过早相遇，必然有一个早早淘汰出局。

因此1号种子和2号种子如果中途没有爆冷出局，那么他们只可能在决赛（第7轮）相遇。

这里引出了同样的问题：任意给定两个选手，如何判断他们在第几轮相遇。

不同匹配规则下相遇轮次是不一样的，我们希望都能够支持。

### 实现

现实世界中多是1-based，头号种子就是1，但是大多数编程语言又是0-based，第一个数字是0而不是1。

因此面向用户采用1-based，实现细节采用0-based。（后续会看到0-based在位运算中的优势）

我们以0-based的64人淘汰赛为例。

#### 紧邻连续匹配

##### 第一轮

```
0	1		000000	000001
2	3		000010	000011
4	5		000100	000101
6	7		000110	000111
8	9		001000	001001
10	11		001010	001011
12	13		001100	001101
14	15		001110	001111
16	17		010000	010001
18	19		010010	010011
20	21		010100	010101
22	23		010110	010111
24	25		011000	011001
26	27		011010	011011
28	29		011100	011101
30	31		011110	011111
32	33		100000	100001
34	35		100010	100011
36	37		100100	100101
38	39		100110	100111
40	41		101000	101001
42	43		101010	101011
44	45		101100	101101
46	47		101110	101111
48	49		110000	110001
50	51		110010	110011
52	53		110100	110101
54	55		110110	110111
56	57		111000	111001
58	59		111010	111011
60	61		111100	111101
62	63		111110	111111
观察二进制表示得出结论：有且只有最后一个bit不一致，即p^q=0b1。
这里的一个陷阱是q-p=1，那么就无法解释54为什么必须和55配对而不是53配对。
其次p和q是可交换的，但是q-p=1不满足交换律。
```

##### 第二轮

```
0/1		2/3			000000/000001	000010/000011
4/5		6/7			000100/000101	000110/000111
8/9		10/11		001000/001001	001010/001011
12/13	14/15		001100/001101	001110/001111
16/17	18/19		010000/010001	010010/010011
20/21	22/23		010100/010101	010110/010111
24/25	26/27		011000/011001	011010/011011
28/29	30/31		011100/011101	011110/011111
32/33	34/35		100000/100001	100010/100011
36/37	38/39		100100/100101	100110/100111
40/41	42/43		101000/101001	101010/101011
44/45	46/47		101100/101101	101110/101111
48/49	50/51		110000/110001	110010/110011
52/53	54/55		110100/110101	110110/110111
56/57	58/59		111000/111001	111010/111011
60/61	62/63		111100/111101	111110/111111
有了前面的基础，知道p^q是可能的线索。
虽然有4种组合方式，但是只有最后2个bit不一致，因此只有p^q=0b10或者p^q=0b11两种情况。
```

##### 第三轮

```
000000/000001/000010/000011		000100/000101/000110/000111
001000/001001/001010/001011		001100/001101/001110/001111
010000/010001/010010/010011		010100/010101/010110/010111
011000/011001/011010/011011		011100/011101/011110/011111
100000/100001/100010/100011		100100/100101/100110/100111
101000/101001/101010/101011		101100/101101/101110/101111
110000/110001/110010/110011		110100/110101/110110/110111
111000/111001/111010/111011		111100/111101/111110/111111
虽然有16种组合，但是只需考虑最后3个bit。
p^q只有4种情况：0b100、0b101、0b110、0b111。
```

##### 第四轮

```
只需要考虑最后4个bit。
p^q有8种情况：0b1000 0b1001 0b1010 0b1011 0b1100 0b1101 0b1110 0b1111。
8种情况的共同规律在于：在二进制表示中都是4位数。
```

##### 第五轮

```
p^q有16种情况，在二进制表示中都是5位数。
```

##### 第六轮

```
p^q有32种情况，在二进制表示中都是6位数。
```

##### 总结

**`p^q`的二进制表示是几位数，那么`p`和`q`就在第几轮相遇。**

| 轮次 |                             p^q                              |    备注     |
| :--: | :----------------------------------------------------------: | :---------: |
|  1   |                              1                               | 1位二进制数 |
|  2   |                            10 11                             | 2位二进制数 |
|  3   |                       100 101 110 111                        | 3位二进制数 |
|  4   |       1000 1001 1010 1011<br/>1100 1101 1110 1111<br/>       | 4位二进制数 |
|  5   | 10000 10001 10010 10011<br/>10100 10101 10110 10111<br/>11000 11001 11010 11011<br/>11100 11101 11110 11111<br/> | 5位二进制数 |
|  6   |                             ...                              | 6位二进制数 |

#### 首尾对称匹配

##### 第一轮

```
0	63		000000	111111
1	62		000001	111110
2	61		000010	111101
3	60		000011	111100
4	59		000100	111011
5	58		000101	111010
6	57		000110	111001
7	56		000111	111000
8	55		001000	110111
9	54		001001	110110
10	53		001010	110101
11	52		001011	110100
12	51		001100	110011
13	50		001101	110010
14	49		001110	110001
15	48		001111	110000
16	47		010000	101111
17	46		010001	101110
18	45		010010	101101
19	44		010011	101100
20	43		010100	101011
21	42		010101	101010
22	41		010110	101001
23	40		010111	101000
24	39		011000	100111
25	38		011001	100110
26	37		011010	100101
27	36		011011	100100
28	35		011100	100011
29	34		011101	100010
30	33		011110	100001
31	32		011111	100000
p+q=63，也满足交换律。有了紧邻连续匹配的经验，记作p^q=0b111111更合适。
```

##### 第二轮

```
000000/111111	011111/100000
000001/111110	011110/100001
000010/111101	011101/100010
000011/111100	011100/100011
000100/111011	011011/100100
000101/111010	011010/100101
000110/111001	011001/100110
000111/111000	011000/100111
001000/110111	010111/101000
001001/110110	010110/101001
001010/110101	010101/101010
001011/110100	010100/101011
001100/110011	010011/101100
001101/110010	010010/101101
001110/110001	010001/101110
001111/110000	010000/101111
有了紧邻连续匹配的经验，第二轮虽然有4种组合但应该只有2种情况。
观察二进制表示可得出：p^q=011111或者p^q=100000
```

##### 第三轮

```
000000/111111/011111/100000		001111/110000/010000/101111
000001/111110/011110/100001		001110/110001/010001/101110
000010/111101/011101/100010		001101/110010/010010/101101
000011/111100/011100/100011		001100/110011/010011/101100
000100/111011/011011/100100		001011/110100/010100/101011
000101/111010/011010/100101		001010/110101/010101/101010
000110/111001/011001/100110		001001/110110/010110/101001
000111/111000/011000/100111		001000/110111/010111/101000
p^q有4种情况：0b001111、0b010000、0b101111、0b110000。
```

##### 第四轮

```
p^q有8种情况：000111 001000 010111 011000 100111 101000 110111 111000。
8种情况的共同规律在于：在二进制表示中尾部有3个连续1或者3个连续0。
```

##### 第五轮

```
p^q有16种情况，在二进制表示中尾部有2个连续1或者2个连续0。
```

##### 第六轮

```
p^q有32种情况，在二进制表示中尾部有1个连续1或者1个连续0。
```

##### 总结

**`p^q`的二进制表示尾部有几个连续的0或1，那么`p`和`q`就在倒数第几轮相遇。**

| 轮次 |                             p^q                              |      备注      |
| :--: | :----------------------------------------------------------: | :------------: |
|  1   |                            111111                            |  尾部连续6个1  |
|  2   |                        011111 100000                         | 尾部连续5个1/0 |
|  3   |             001111 010000<br/>101111 110000<br/>             | 尾部连续4个1/0 |
|  4   | 000111 001000<br/>010111 011000<br/>100111 101000<br/>110111 111000<br/> | 尾部连续3个1/0 |
|  5   | 000011 000100<br/>001011 001100<br/>010011 010100<br/>011011 011100<br/>100011 100100<br/>101011 101100<br/>110011 110100<br/>111011 111100<br/> | 尾部连续2个1/0 |
|  6   |                                                              | 尾部连续1个1/0 |

#### 晋级过程中遇到的对手

除了第一轮的对手是确定的，以及两位选手相遇时是确定的，在其它轮次都有多种可能。

因此两者相遇过程中淘汰的对手并不能唯一确定。

### Examples

##### 紧邻连续匹配

```go
package main

import (
	"fmt"

	"github.com/Neightly/juzhongmishi/pkg/gamematcher"
)

func main() {
	game := gamematcher.New(64)     // 七脉会武是64人紧邻连续匹配的比赛
	l := game.MatchCloseNext(1, 33) // 1号张小凡和33号曾书书只能在决赛（第6轮）相遇
	fmt.Println(l)
	// Output: 6
}
```

##### 首尾对称匹配

```go
package main

import (
	"fmt"

	"github.com/Neightly/juzhongmishi/pkg/gamematcher"
)

func main() {
	game := gamematcher.New(128)  // 网球大满贯是128人首尾对称匹配的比赛
	l := game.MatchHeadTail(1, 2) // 1号种子和2号种子只能在决赛（第7轮）相遇
	fmt.Println(l)
	// Output: 7
}
```
